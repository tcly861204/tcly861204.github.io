<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[underscore源码学习]]></title>
    <url>%2F2019%2F09%2F10%2Funderscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071(function()&#123; const root = (typeof self === 'object' &amp;&amp; self.self === self &amp;&amp; self) || (typeof global === 'object' &amp;&amp; global.global === global &amp;&amp; global) || this || &#123;&#125;; const _ = function(obj) &#123; if (obj instanceof _) return obj; if(!(this instanceof _)) return new _(obj); this._wrapped = obj || [] &#125; const ArrayProto = Array.prototype; const push = ArrayProto.push; if (typeof exports != 'undefined' &amp;&amp; !exports.nodeType) &#123; if (typeof module != 'undefined' &amp;&amp; !module.nodeType &amp;&amp; module.exports) &#123; exports = module.exports = _; &#125; exports._ = _; &#125; else &#123; root._ = _; &#125; _.VERSION = '0.1'; _.each = function (arr, cb) &#123; let i = 0; let Len = arr.length; while(i &lt; Len) &#123; if (_.isFunction(cb)) &#123; cb.call(arr[i], arr[i], i) &#125; i++ &#125; return this &#125; _.isFunction = function(obj) &#123; return typeof obj == 'function' || false; &#125;; _.functions = function(obj) &#123; const names = []; for(let key in obj) &#123; if (_.isFunction(obj[key])) names.push(key); &#125; return names.sort(); &#125; _.mixin = function(obj) &#123; _.each(_.functions(obj), function(name) &#123; var func = _[name] = obj[name]; _.prototype[name] = function() &#123; let fn = null _.each(Array.from(arguments), item =&gt; &#123; if (!_.isFunction(item)) &#123; this._wrapped = [...this._wrapped, ...item] &#125; else &#123; fn = item &#125; &#125;) if (!fn) &#123; return this &#125; let args = [this._wrapped]; push.apply(args, [fn]); return func.apply(_, args); &#125;; &#125;); return _; &#125;; _.mixin(_)&#125;)()]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>underscore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3内存溢出]]></title>
    <url>%2F2019%2F09%2F04%2Fvue-cli3%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[起因本地一个项目是使用vue-cli2构建的，可以正常运行。打算升级到vue-cli@3，遭遇了运行npm run dev无法运行，爆出JavaScript heap out of memory 的问题。 vue-cli2遇到此问题的解决办法： npm run dev 和 npm run build 直接在前面加上--max_old_space_size=4096 vue-cli3遇到此问题的解决办法： scripts中添加一句指令安装两个npm包 ： increase-memory-limit 和cross-env安装完成后，先执行一次 npm run fix-memory-limit，然后yarn serve启动即可 12345678910"scripts": &#123; "serve": "vue-cli-service serve", "build": "vue-cli-service build", "fix-memory-limit": "cross-env LIMIT=4096 increase-memory-limit",&#125;,# 同时安装 2 个依赖包"devDependencies": &#123; "increase-memory-limit": "^1.0.3", "cross-env": "^5.0.5"&#125; vue-cli3 的解决办法找了半天才找到，说一下修复原理。它不能像vue-cli2直接在 npm run dev中间添加一个参数，我尝试了几种方法只有使用安装模块fix-memory-limit的方式生效，其原理是修改了node_modules中一个叫做.bin（通常就是第一个文件夹）的文件夹内所有文件权限。 方法一：在package.json中scripts原基础上添加参数，以及尝试使用npx。不行。 方法二： 在node_modules中的vue-cli-sevie源代码中添加一句。 不行。 原文地址https://blog.csdn.net/win7583362/article/details/86305780]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>build</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这些WebAPI真的有用吗? 别问, 问就是有用🈶]]></title>
    <url>%2F2019%2F08%2F25%2F%E8%BF%99%E4%BA%9BWebAPI%E7%9C%9F%E7%9A%84%E6%9C%89%E7%94%A8%E5%90%97%2F</url>
    <content type="text"><![CDATA[本文列举了一些列比较不常见的Web API，内容较多，所以有关兼容性的内容在本文不会出现，大家可以自己去查阅。 以下案例能配动图的我尽量去配了，以免内容枯草乏味，但是如果内容有误，也请大家亲喷或者纠正👌 方法列表 querySelector（元素向下查询，返回一个） querySelectorAll（元素向下查询，返回多个） closest（元素向上查询） dataset（获取元素以”data-“为前缀的属性集合） URLSearchParams（查询参数） hidden（隐藏元素） contenteditable（使元素可以被编辑） spellCheck（检查拼音） classList（类名控制器） getBoundingClientRect（元素空间结构详细信息） contains（判断是否包含指定元素） online state（网络状态） battery state（电池状态） vibration（设备震动） page visibility（页面可见性） deviceOrientation（陀螺仪） toDataUrl（画布内容转base64） customEvent（自定义事件） notification（桌面通知） fullScreen（全屏） orientation（屏幕方向） 逐个击破querySelector都9102年了，还在用getElementById吗😭获取指定元素中匹配css选择器的元素： 12345678// 作用在documentdocument.querySelector("#nav"); // 获取文档中id="nav"的元素document.querySelector(".nav"); // 获取文档中class="nav"的元素document.querySelector("#nav li:first-child"); // 获取文档中id="nav"下面的第一个li元素// 也可以作用在其他元素let nav = dodocument.querySelector("#nav");nav.querySelector("li"); // 如果有多个li的话，返回第一个li querySelectorAll获取指定元素中匹配css选择器的所有元素： 1let list = document.querySelectorAll("li"); // NodeList(2) [li, li] 这里假设返回2个 注意：返回的值是一个类数组，无法使用数组的原生方法（forEach、map等），需要转换一下： 1Array.from(list).map(); closest跟querySelector相反，该元素可以向上查询，也就是可以查询到父元素： 1document.querySelector("li").closest("#nav"); dataset就跟原生微信小程序一样，能获取标签上以”data-“为前缀的属性集合： 1&lt;p data-name="蜘蛛侠" data-age="16"&gt;&lt;/p&gt; 1document.querySelector("p").dataset; // &#123;name: "蜘蛛侠", age: "16"&#125; 注意：虽然可以用getAttribute方法获取任何属性值，但是性质却不一样，这是开发规范问题，凡是自定义属性都要加上data-前缀哦✅ URLSearchParams假设浏览器的url参数是 “?name=蜘蛛侠&amp;age=16” 1new URLSearchParams(location.search).get("name"); // 蜘蛛侠 hidden这是一个html属性，规定元素是否隐藏，表现跟css的display: none一致：12&lt;div hidden&gt;我被隐藏了&lt;/div&gt;document.querySelector("div").hidden = true / false; contenteditable可以使一个元素可以被用户编辑：1&lt;p contenteditable&gt;我是P元素，但是我也可以被编辑&lt;/p&gt; 效果如下： 如果这个属性跟style标签相遇会产生一段非常奇妙的故事： contenteditable跟user-modify还能这么玩🌚 spellcheck也是一个html属性，规定输入的内容是否检查英文的拼写：12&lt;!-- 默认就是true，可省略 --&gt;&lt;textarea spellcheck="true"&gt;&lt;/textarea&gt; 效果如下： 设置不检查：1&lt;textarea spellcheck="false"&gt;&lt;/textarea&gt; 效果如下： classList这是一个对象，该对象里封装了许多操作元素类名的方法：1&lt;p class="title"&gt;&lt;/p&gt; 12345678910111213141516let elem = document.querySelector("p");// 增加类名elem.classList.add("title-new"); // "title title-new"// 删除类名elem.classList.remove("title"); // "title-new"// 切换类名（有则删、无则增，常用于一些切换操作，如显示/隐藏）elem.classList.toggle("title"); // "title-new title"// 替换类名elem.classList.replace("title", "title-old"); // "title-new title-old"// 是否包含指定类名elem.classList.contains("title"); // false getBoundingClientRect可以获取指定元素在当前页面的空间信息： 12345678910111213elem.getBoundingClientRect();// 返回&#123; x: 604.875, y: 1312, width: 701.625, height: 31, top: 1312, right: 1306.5, bottom: 1343, left: 604.875&#125; 注意：top是距离文档顶部的距离，y则是距离可视窗口（浏览器屏幕）的顶部距离，如果浏览器滚动，top值不变，y值会变 ✅ contains可以判断指定元素是否包含了指定的子元素：123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 1document.querySelector("div").contains(document.querySelector("p")); // true online state监听当前的网络状态变动，然后执行对应的方法：1234window.addEventListener("online", xxx);window.addEventListener("offline", () =&gt; &#123; alert("你断网啦！");&#125;); PC端效果如下： 移动端效果如下：使用场景：提示用户已断网，直接一个弹框把用户吓懵✅ battery state获取设备的电池状态：1234567891011121314navigator.getBattery().then(battery =&gt; console.log(battery));// 返回&#123; charging, // 是否在充电 chargingTime, // 充满电所需时间 dischargingTime, // 当前电量可使用时间 level, 剩余电量 onchargingchange, // 监听充电状态变化 onchargingtimechange, // 监听充满电所需时间变化 ondischargingtimechange, // 监听当前电量可使用时间变化 onlevelchange // 监听电量变化&#125; 使用场景：提示用户电量已充满，或者为了让用户有安全感，电量低于99%的时候来个弹框提示”该充电啦”✅ vibration嘻嘻，使设备进行震动：12345// 震动一次navigator.vibrate(100);// 连续震动，震动200ms、暂停100ms、震动300msnavigator.vibrate([200, 100, 300]); 效果如下：不好意思你得用你自己的手握住手机才能感受得到;使用场景：通过振动来提供感官反馈，比如太久没有触摸屏幕的时候连续震动提醒用户✅ page visibility顾名思义，这个API是用来监听页面可见性变化的，在PC端标签栏切换、最小化会触发、在移动端程序切到后台会触发，简单说就是页面消失了🤦‍♂️123document.addEventListener("visibilitychange", () =&gt; &#123; console.log(`页面可见性：$&#123;document.visibilityState&#125;`);&#125;); PC端效果如下： 移动端效果如下：使用场景：当程序切到后台的时候，如果当前有视频播放或者一些动画执行，可以先暂停✅ deviceOrientation陀螺仪，也就是设备的方向，又名重力感应，该API在IOS设备上失效的解决办法，将域名协议改成https； 从左到右分别为alpha、beta、gamma;1234567891011window.addEventListener("deviceorientation", event =&gt; &#123; let &#123; alpha, beta, gamma &#125; = event; console.log(`alpha：$&#123;alpha&#125;`); console.log(`beta：$&#123;beta&#125;`); console.log(`gamma：$&#123;gamma&#125;`);&#125;); 移动端效果如下（此时手机在不停的转动）： 使用场景：页面上的某些元素需要根据手机摆动进行移动，达到视差的效果，比如王者荣耀进入游戏的那个界面，手机转动背景图会跟着动😂 toDataURL这个canvas的API，作用是将画布的内容转换成一个base64的图片地址； 1234567let canvas = document.querySelector("canvas");let context = canvas.getContext("2d");// 画东西...let url = canvas.toDataURL("image/png"); // 将画布内容转换成base64地址 使用a标签进行图片下载时，图片链接跨域（图片是我的掘金头像），无法进行下载而是进行图片预览：12345&lt;img src="xxx"&gt;&lt;button&gt; &lt;a href="xxx" download="avatar"&gt;下载图片&lt;/a&gt;&lt;/button&gt; 效果如下： 封装以下代码便可解决✅123456789101112131415161718192021222324252627282930const downloadImage = (url, name) =&gt; &#123; // 实例化画布 let canvas = document.createElement("canvas"); let context = canvas.getContext("2d"); // 实例化一个图片对象 let image = new Image(); image.crossOrigin = "Anonymous"; image.src = url; // 当图片加载完毕 image.onload = () =&gt; &#123; // 将图片画在画布上 canvas.height = image.height; canvas.width = image.width; context.drawImage(image, 0, 0); // 将画布的内容转换成base64地址 let dataURL = canvas.toDataURL("image/png"); // 创建a标签模拟点击进行下载 let a = document.createElement("a"); a.hidden = true; a.href = dataURL; a.download = name; document.body.appendChild(a); a.click(); &#125;&#125; 效果如下： 或者将当前的DOM转换成图片进行下载，常用于生成海报： html2canvas customEvent自定义事件，就跟vue里面的on跟emit一样；监听自定义事件：123window.addEventListener("follow", event =&gt; &#123; console.log(event.detail); // 输出 &#123;name: "前端宇宙情报局"&#125;&#125;); 派发自定义事件：12345window.dispatchEvent(new CustomEvent("follow", &#123; detail: &#123; name: "前端宇宙情报局" &#125;&#125;)); notificationPC端的桌面通知，如网页端的微信，当收到消息时，右下角会出现一个通知（尽管你把浏览器最小化），因为这个通知时独立于浏览器的，是系统的一个原生控件； 123456789101112const notice = new Notification("前端宇宙情报局", &#123; body: "这20个不常用的Web API真的有用吗?，别问，问就是有用🈶", icon: "我的掘金头像", data: &#123; url: "https://www.baidu.com" &#125;&#125;);// 点击回调notice.onclick = () =&gt; &#123; window.open(notice.data.url); // 当用户点击通知时，在浏览器打开百度网站&#125; 效果如下： 注意：想要成功的调起通知，首先要用户的授权✅1234Notification.requestPermission(prem =&gt; &#123; prem == "granted" // 同意 prem == "denied" // 拒绝&#125;) 所以，再调用之前先向用户发起请求：1234567891011let permission = Notification.permission;if (permission == "granted") &#123; // 已同意，开始发送通知 ...&#125; else if (permission == "denied") &#123; // 不同意，发不了咯&#125; else &#123; // 其他状态，可以重新发送授权提示 Notification.requestPermission();&#125; fullScreen全屏不咯? 之前的一个项目刚好用上，不仅仅可以作用在documentElement上，还可以作用在指定元素；12345678910111213/** * @method launchFullScreen 开启全屏 * @param &#123;Object&#125; elem = document.documentElement 作用的元素 */const launchFullScreen = (elem = document.documentElement) =&gt; &#123; if(elem.requestFullScreen) &#123; elem.requestFullScreen(); &#125; else if(elem.mozRequestFullScreen) &#123; elem.mozRequestFullScreen(); &#125; else if(elem.webkitRequestFullScreen) &#123; elem.webkitRequestFullScreen(); &#125;&#125; 作用在documentElement上没啥可以介绍的咯，就相当于F11开启全屏： 那么作用在指定元素会是什么效果呢? 就像效果图一样，会直接开启全屏，并且只显示指定的元素，元素的宽高填充了整个屏幕✅关闭全屏的时候需要注意的是，统一用document对象：123456789101112/** * @method exitFullScreen 关闭全屏 */const exitFullScreen = () =&gt; &#123; if (document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if (document.webkitCancelFullScreen) &#123; document.webkitCancelFullScreen(); &#125;&#125; 使用场景：需要让用户专注去做某件事，比如代码编辑区的全屏✅ orientation可以监听用户手机设备的旋转方向变化；123window.addEventListener("orientationchange", () =&gt; &#123; document.body.innerHTML += `&lt;p&gt;屏幕旋转后的角度值：$&#123;window.orientation&#125;&lt;/p&gt;`;&#125;, false); 效果如下： 也可以使用css的媒体查询：12345678910111213/* 竖屏时样式 */@media all and (orientation: portrait) &#123; body::after &#123; content: "竖屏" &#125;&#125;/* 横屏时样式 */@media all and (orientation: landscape) &#123; body::after &#123; content: "横屏" &#125;&#125; 使用场景：页面需要用户开启横屏来获得更好的体验，如王者荣耀里面的活动页😂 总结其实不常用的还有很多很多，有一些我没有发现或者没写，如geoLocation地理定位、execCommand执行命令等，也欢迎大家补充，前几篇文章都是css相关，后面几篇先不写css啦，为好多内容大家都写过，想写一些新的，但是又难免会冲突~]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页多线程webwork]]></title>
    <url>%2F2019%2F08%2F23%2F%E7%BD%91%E9%A1%B5%E5%A4%9A%E7%BA%BF%E7%A8%8Bwebwork%2F</url>
    <content type="text"><![CDATA[webwork多线程技术在服务端技术中已经发展的很成熟了，而在Web端的应用中却一直是鸡肋在新的标准中，提供的新的WebWork API，让前端的异步工作变得异常简单。使用：创建一个Worker对象，指向一个js文件，然后通过Worker对象往js文件发送消息，js文件内部的处理逻辑，处理完毕后，再发送消息回到当前页面，纯异步方式，不影响当前主页面渲染。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; //创建线程 work对象 var work = new Worker("work.js"); //发送消息 work.postMessage("100"); // 监听消息 work.onmessage = function(event) &#123; alert(event.data); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; work.js1234567891011121314151617181920212223242526272829303132333435363738394041// 基本用法onmessage = function (event) &#123; //从1加到num var num = event.data; //通过event接收数据 var result = 0; for (var i = 1; i &lt;= num; i++) &#123; result += i; &#125; postMessage(result); // 通过此方法对外抛数据&#125;// work.js 内部可以通过ajax 或 fetch 与服务端交互// fetch 推荐addEventListener("message", function(event) &#123; let postData = JSON.parse(event.data); fetch(`date.json?a=$&#123;postData.a&#125;&amp;b=$&#123;postData.b&#125;`).then(function(response) &#123; return response.json(); &#125;).then(function(data) &#123; console.log(data); postMessage(data); &#125;).catch(function(e) &#123; console.log("Oops, error"); &#125;);&#125;, false);// ajax版addEventListener("message", function(event) &#123; let postData = JSON.parse(event.data); let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; console.log(xhr.status) if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304)&#123; postMessage(xhr.responseText); &#125;else if(xhr.status &gt;=400)&#123; console.log("错误信息：" + xhr.status) &#125; &#125; xhr.open('GET', `date.json?a=$&#123;postData.a&#125;&amp;b=$&#123;postData.b&#125;`, true); xhr.send()&#125;, false);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>webwork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-fetch的用法]]></title>
    <url>%2F2019%2F08%2F23%2FES6-fetch%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Fetchfetch是用来取代传统的XMLHttpRequest的。 它的优点很多，包括链式调用的语法、返回promise等。fetch api是基于promise的设计，它是为了取代传统xhr的不合理的写法而生的。 传统ajaxxhr请求写起来非常的混乱，如下所示 12345678910var xhr = new XMLHttpRequest();xhr.open('GET', url);xhr.responseType = 'json';xhr.onload = function() &#123; console.log(xhr.response);&#125;;xhr.onerror = function() &#123; console.log("Oops, error");&#125;;xhr.send(); 但是使用fetch之后，如下所示：1234567fetch(url).then(function(response) &#123; return response.json();&#125;).then(function(data) &#123; console.log(data);&#125;).catch(function(e) &#123; console.log("Oops, error");&#125;); 这种链式调用的风格看上去会非常舒服。 如果我们再使用了箭头函数就会更加简洁了。1234567891011121314fetch(url).then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log("Oops, error", e))``` 通过使用fetch api，可以将传统的xhr的粗糙的使用方法转化的如此精简，实在是好！# Fetch API&gt; Fetch API提供了一个fetch()方法，它被定义在BOM的window对象中，你可以用它来发起对远程资源的请求。 该方法返回的是一个Promise对象，让你能够对请求的返回结果进行检索。 + 通过fetch的形式获取数据 + JSONP、CORS、服务器跨域 + CORS请求头 Access-Control-Allow-Origin”, “*” //所有的网站Access-Control-Allow-Headers”, “Content-Type,Content-Length, Authorization, Accept,X-Requested-With”Access-Control-Allow-Methods”,”PUT,POST,GET,DELETE,OPTIONS” //Restful请求规范 支持符合Restful的所有协议 12# fetch只支持跨域CORS 不支持JSONP跨越 //fetch发送数据 //支持CORS跨域,没有办法接受jsonp数据 function getData() { //支持 cors跨域url地址’http://api.yytianqi.com/air?city=CH010100&amp;key=2c5br4sgmguremgg&#39; //https://api.douban.com/v2/book/1220562?callback=func return fetch(‘http://localhost:3001/getdata&#39;) .then(function (response) { console.log(response); //promise对象返回 return response.json(); }) } getData().then(function (data) { console.log(data); })1234567891011# fetch-jsonp跨域是可以支持jsonp跨域&gt; npm install fetch-jsonp//fetch所支持的jsonp发送数据请求 function getFetchJSONP()&#123; // return fetchJsonp('https://api.douban.com/v2/book/1220562',&#123; return fetchJsonp('http://localhost:3001/getjsonp',&#123; //告诉fetchjsonp使用jsonp跨域 jsonpCallback: 'callback' &#125;) .then(function (response) &#123; //拿到整个响应数据 //返回响应中的主要数据 return response.json(); &#125;) &#125; getFetchJSONP().then(function (data) &#123; console.log(data); &#125;)# JSONP、CORS、服务器跨域 3种跨域方案跨域方案很多，除了这三种，还有active控件 iframe 跨域不安全，不推荐跨域 var express =require(‘express’);var app=new express();var request=require(‘request’); //1 CORS跨域app.use(function (req,res,next) { //每一次发送的请求头 //支持cors跨域 res.header(‘Access-Control-Allow-Origin’,’*’); next();});app.get(‘/getdata’,function (req,res) { res.send(‘{“text”:”CORS跨域”}’);});//2 jsonp跨域app.get(‘/getjsonp’,function (req,res) { console.log(req.query.callback); console.log(req.querystring); res.send(;${req.query.callback}({&quot;text&quot;:&quot;CORS跨域&quot;}););});//3 服务器转发跨域app.get(‘/request’,function (req,res) { var url=’https://api.douban.com/v2/book/1220562&#39; request(url,function (error,response,body) { console.log(body); if(!error){ res.send(body); } }) });app.listen(‘3001’,function(){ console.log(‘端口3001被打开了’);});`]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue实现自定义窗口]]></title>
    <url>%2F2019%2F07%2F31%2Fvue%E7%AA%97%E5%8F%A3%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[窗口调用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import Vue from 'vue'let iNum = 0let _components = &#123;&#125;const _util = &#123; // 查找对应的模板组件 hasTemplate (__file) &#123; return new Promise((resolve, reject) =&gt; &#123; let _find = false _components[__file].model.$children.map(child =&gt; &#123; if ('model__' in child &amp;&amp; child.model__ === 'iv-custom-model' &amp;&amp; child.$options.componentName === 'CustModelTemplate') &#123; _find = true resolve(child) &#125; &#125;) if (!_find) &#123; reject(_find) &#125; &#125;) &#125;, // 查找组件 findComponent (config) &#123; let __file = null Object.keys(_components).map(key =&gt; &#123; if (_components[key].component === config.component) &#123; __file = key &#125; &#125;) return __file &#125;, // 创建示例 created (config) &#123; iNum++ const Model = Vue.extend(config.component) let options = &#123; provide () &#123; return &#123; app: Object.assign(&#123;&#125;, config.app || &#123;&#125;), model: this &#125; &#125; &#125; if (config.router) &#123; options.router = config.router &#125; options.data = Object.assign(&#123; app: config.app || &#123;&#125; &#125;, config.options) let _model = new Model(options) _model.$mount() document.body.appendChild(_model.$el) const __file = 'model_' + iNum _components[__file] = &#123; component: config.component, model: _model, // model listen: false // 是否加入了监听 &#125; _CustModel.show(__file) this.listeners(config, __file) &#125;, // 监听 listeners (config, __file) &#123; Object.keys(_components).map(key =&gt; &#123; let cp = _components[key] if (!cp.listen) &#123; cp.listen = true let _listen = Object.assign(&#123; close: () =&gt; &#123;&#125;, update: null, router: null &#125;, ('on' in config &amp;&amp; typeof config.on === 'object') ? config.on : &#123;&#125;) Object.keys(_listen).map(key =&gt; &#123; switch (key) &#123; case 'close': case 'router': case 'update': if (_listen[key] &amp;&amp; typeof _listen[key] === 'function') &#123; cp.model.$on(`on-$&#123;key&#125;`, (...args) =&gt; &#123; _listen[key].apply(cp.model, args) if (key === 'close' || key === 'router') &#123; if ('destroy' in config &amp;&amp; config.destroy) &#123; _CustModel.destroy(config) &#125; else &#123; _CustModel.hide(config) &#125; &#125; &#125;) &#125; break default: // 用以匹配任意方法 cp.model.$on(`on-$&#123;key&#125;`, (...args) =&gt; &#123; _listen[key].apply(cp.model, args) &#125;) &#125; &#125;) &#125; return cp &#125;) &#125;&#125;const _CustModel = &#123; // 创建入口 install (config) &#123; if (!config.component) &#123; return &#125; let __file = _util.findComponent(config) if (__file) &#123; if ('options' in config &amp;&amp; typeof config.options === 'object') &#123; Object.keys(config.options).map(key =&gt; &#123; _components[__file].model._data[key] = config.options[key] &#125;) &#125; this.show(__file) &#125; else &#123; _util.created(config) &#125; &#125;, // 示例显示 show: function (__file) &#123; _util.hasTemplate(__file).then(child =&gt; &#123; child.visible = true &#125;) &#125;, // 示例隐藏 hide: function (config) &#123; if (config &amp;&amp; config.component) &#123; let __file = _util.findComponent(config) if (__file) &#123; _util.hasTemplate(__file).then(child =&gt; &#123; child.visible = false &#125;) &#125; &#125; &#125;, // 销毁 destroy: function (config) &#123; if (config &amp;&amp; config.component) &#123; let __file = _util.findComponent(config) if (__file) &#123; _components[__file].model.$destroy(true) _components[__file].model.$el.parentNode.removeChild(_components[__file].model.$el) _components[__file] = null delete _components[__file] &#125; &#125; &#125;&#125;export default _CustModel 配套窗口模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337&lt;template&gt; &lt;div class="iv-custom-mask" v-show="visible" :style="maskStyle" @click.stop="onCloseHandle"&gt; &lt;div class="iv-custom-model" ref="model" :style="styles"&gt; &lt;section class="iv-custom-model__header" @mousedown.stop="onMouseDownHandle" :style="headStyle" v-if="header"&gt; &lt;i v-if="icon" :style="`font-size: $&#123;iconSize&#125;px`" :class="['title-icon', icon]" /&gt; &lt;slot class="iv-custom-model__header-title" name="header"&gt; &lt;h2 class="iv-custom-model__header-title" :style="titleStyle"&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;/slot&gt; &lt;i v-if="full" :class="['full', 'ivu-icon', `ivu-icon-$&#123;fullFlag ? 'ios-contract' : 'ios-expand'&#125;`]" @click="onFullHandle" /&gt; &lt;i class="close omd omd-close" @click.stop="onCloseHandle" /&gt; &lt;/section&gt; &lt;section class="iv-custom-model__main" :style="mainStyles"&gt; &lt;Spin fix v-if="pageLoading"&gt;&lt;/Spin&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/section&gt; &lt;section class="iv-custom-model__footer" :style="footStyle" v-if="footer"&gt; &lt;div class="iv-custom-model__footer-prefix"&gt; &lt;slot name="footPrefix" /&gt; &lt;/div&gt; &lt;div class="iv-custom-model__footer-btns"&gt; &lt;slot name="footer"&gt; &lt;Button type="text" :size="footButtonSize" @click="onCancelHandle"&gt;&#123;&#123;cancelText&#125;&#125;&lt;/Button&gt; &lt;Button type="primary" :size="footButtonSize" :disabled="saveDisabled" :loading="loading" @click="onSaveHandle"&gt;&#123;&#123;okText&#125;&#125;&lt;/Button&gt; &lt;/slot&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'iv-custom-model', componentName: 'CustModelTemplate', props: &#123; loading: &#123; type: Boolean, default: false &#125;, pageLoading: &#123; type: Boolean, default: false &#125;, icon: &#123; type: String, default: '' &#125;, iconSize: &#123; type: [String, Number], default: 22 &#125;, mask: &#123; type: Boolean, default: false &#125;, full: &#123; type: Boolean, default: false &#125;, header: &#123; type: Boolean, default: true &#125;, headHeight: &#123; type: [ Number, String ], default: 50 &#125;, footer: &#123; type: Boolean, default: true &#125;, footHeight: &#123; type: [ Number, String ], default: 50 &#125;, footButtonSize: &#123; type: String, default: 'default' &#125;, cancelText: &#123; type: String, default: '取消' &#125;, okText: &#123; type: String, default: '保存' &#125;, title: &#123; type: String, default: '' &#125;, zIndex: &#123; type: Number, default: 2 &#125;, titleStyle: &#123; type: Object, default: () =&gt; &#123; return &#123;&#125; &#125; &#125;, saveDisabled: &#123; type: Boolean, default: false &#125;, // 是否自定义位置 默认居中 position: &#123; type: Boolean, default: false &#125;, bgColor: &#123; type: String, default: '#f5f5f5' &#125;, top: &#123; type: [Number, String], default: 0 &#125;, left: &#123; type: [Number, String], default: 0 &#125;, width: &#123; type: [Number, String], default: 600 &#125;, height: &#123; type: [Number, String], default: 420 &#125; &#125;, data () &#123; return &#123; fullFlag: false, mouseMoveHandle: null, mouseUpHandle: null, visible: false, model__: 'iv-custom-model', dist: &#123; isMove: false, disX: 0, disY: 0, left: 0, top: 0 &#125; &#125; &#125;, watch: &#123; visible: &#123; handler (v) &#123; this.$emit('on-visible-change', v) &#125; &#125;, immediate: true, deep: true &#125;, computed: &#123; maskStyle () &#123; if (this.mask) &#123; return &#123; zIndex: this.zIndex, background: `rgba(0, 0, 0, 0.2)` &#125; &#125; else &#123; return &#123; zIndex: this.zIndex, background: `rgba(0, 0, 0, 0)` &#125; &#125; &#125;, styles () &#123; if (this.position) &#123; return &#123; width: `$&#123;this.width&#125;px`, height: `$&#123;this.height &gt; window.innerHeight ? (window.innerHeight - 40) : this.height&#125;px`, top: `$&#123;this.top&#125;px`, left: `$&#123;this.left&#125;px`, margin: 'unset' &#125; &#125; return &#123; width: `$&#123;this.width&#125;px`, height: `$&#123;this.height&#125;px` &#125; &#125;, headStyle () &#123; return &#123; cursor: `$&#123;this.position ? 'move' : 'default'&#125;`, height: `$&#123;this.headHeight&#125;px`, lineHeight: `$&#123;this.headHeight&#125;px` &#125; &#125;, footStyle () &#123; return &#123; height: `$&#123;this.headHeight&#125;px`, lineHeight: `$&#123;this.headHeight&#125;px` &#125; &#125;, mainStyles () &#123; let _header = this.header ? parseInt(this.headHeight) : 0 let _footer = this.footer ? parseInt(this.footHeight) : 0 return &#123; height: `calc(100% - $&#123;_header + _footer&#125;px)`, background: this.bgColor &#125; &#125; &#125;, mounted () &#123; let self = this this.mouseMoveHandle = function (e) &#123; if (self.position &amp;&amp; self.dist.isMove) &#123; let x = e.pageX - self.dist.disX let y = e.pageY - self.dist.disY self.$refs.model.style.left = self.dist.left + x + 'px' self.$refs.model.style.top = self.dist.top + y + 'px' &#125; &#125; this.mouseUpHandle = function () &#123; if (self.position &amp;&amp; self.dist.isMove) &#123; self.dist.isMove = false &#125; &#125; window.document.addEventListener('mousemove', this.mouseMoveHandle, false) window.document.addEventListener('mouseup', this.mouseUpHandle, false) &#125;, methods: &#123; _removeEvents () &#123; window.document.removeEventListener('mousemove', this.mouseMoveHandle, false) window.document.removeEventListener('mouseup', this.mouseUpHandle, false) &#125;, onMouseDownHandle (e) &#123; if (!this.position) &#123; return &#125; this.dist.isMove = true this.dist.disX = e.pageX this.dist.disY = e.pageY this.dist.top = parseInt(this.$refs.model.style.top) this.dist.left = parseInt(this.$refs.model.style.left) &#125;, onCancelHandle () &#123; this.$emit('on-close') &#125;, onSaveHandle () &#123; if (!this.loading) &#123; this.$emit('on-save') &#125; &#125;, onFullHandle () &#123; this.fullFlag = !this.fullFlag if (this.fullFlag) &#123; this.$refs.model.style.cssText = `width: $&#123;window.innerWidth&#125;px; height: $&#123;window.innerHeight&#125;px; top: 0; left: 0; z-index: 9999; border-radius: 0; border: none;` &#125; else &#123; this.$refs.model.style.cssText = `width: $&#123;this.width&#125;px; height: $&#123;this.height&#125;px;` &#125; this.$emit('on-full', this.fullFlag) &#125;, onCloseHandle ($event) &#123; if (['iv-custom-mask', 'close omd omd-close'].includes($event.target.className)) &#123; this.$emit('on-close') &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="less" scoped&gt;@borderColor: #e1e1e1;.iv-custom-mask&#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden; z-index: 2;&#125;.iv-custom-model&#123; position: absolute; border: none; margin: auto; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,.15); &amp;__header&#123; background: #fff; border-bottom: 1px solid @borderColor; position: relative; .title-icon&#123; margin: -7px 0 0 15px; &#125; &amp;-title&#123; width: auto; font-weight: normal; padding: 0 15px; display: inline-block; &#125; .close&#123; position: absolute; font-size: 22px; top: 12px; right: 12px; cursor: pointer; &#125; .full&#123; position: absolute; font-size: 20px; top: 13px; right: 38px; cursor: pointer; &#125; &#125; &amp;__main&#123; box-sizing: border-box; padding: 15px; overflow: auto; &#125; &amp;__footer&#123; display: flex; background: #fff; border-top: 1px solid @borderColor; text-align: right; padding: 0 15px; &amp;-prefix&#123; flex: 1; text-align: left; &#125; &amp;-btns&#123; width: auto; &#125; &#125;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javscript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端数据校验从建模开始]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E4%BB%8E%E5%BB%BA%E6%A8%A1%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[前端开发过程中你们觉得处理什么业务功能最烦人？做前端已经有很长一段时间了，不知道大家是否和我有同样的感受，在一些 Web 应用中表单处理起来比其他功能模块都麻烦，很多体力活，往往在数据的校验会很费时间。为了能够把这部分代码更有条理,我们把数据校验部分通过 Schema 预先定义一个数据模型，把数据扔进去，返回校验结果。接下来我介绍一下这个工具，schema-typed 是一个数据建模及数据验证工具, 它可以非常方便的设计的表单数据结构，当然它不限于在表单使用。如果你在产品中使用了 React , 那配合 React Suite 的表单组件简直就是如虎添翼。 安装 npm install schema-typed –save 示例123456789101112131415import &#123; SchemaModel, StringType, DateType, NumberType &#125; from 'schema-typed';const model = SchemaModel(&#123; username: StringType().isRequired('用户名不能为空'), email: StringType().isEmail('请输入正确的邮箱'), age: NumberType('年龄应该是一个数字').range(18, 30, '年龄应该在 18 到 30 岁之间')&#125;);const checkResult = model.check(&#123; username: 'foobar', email: 'foo@bar.com', age: 40&#125;);console.log(checkResult); checkResult 返回结构是:12345&#123; username: &#123; hasError: false &#125;, email: &#123; hasError: false &#125;, age: &#123; hasError: true, errorMessage: '年龄应该在 18 到 30 岁之间' &#125;&#125; 多重验证1234StringType() .minLength(6, '不能少于 6 个字符') .maxLength(30, '不能大于 30 个字符') .isRequired('该字段不能为空'); 自定义验证通过 addRule 函数自定义一个规则。 如果是对一个字符串类型的数据进行验证，可以通过 pattern 方法设置一个正则表达式进行自定义验证。 123456789101112131415161718192021const model = SchemaModel(&#123; field1: StringType().addRule((value, data) =&gt; &#123; return /^[1-9][0-9]&#123;3&#125;\s?[a-zA-Z]&#123;2&#125;$/.test(value); &#125;, '请输入合法字符'), field2: StringType().pattern(/^[1-9][0-9]&#123;3&#125;\s?[a-zA-Z]&#123;2&#125;$/, '请输入合法字符')&#125;);model.check(&#123; field1: '', field2: '' &#125;);/**&#123; field1: &#123; hasError: true, errorMessage: '请输入合法字符' &#125;, field2: &#123; hasError: true, errorMessage: '请输入合法字符' &#125;&#125;;**/ 自定义验证 - 多字段交叉验证例如，验证两次输入密码是否一致 123456789101112131415161718192021const model = SchemaModel(&#123; password1: StringType().isRequired('该字段不能为空'), password2: StringType().addRule((value, data) =&gt; &#123; if (value !== data.password1) &#123; return false; &#125; return true; &#125;, '两次密码不一致')&#125;);model.check(&#123; password1: '123456', password2: 'root' &#125;);/**&#123; password1: &#123; hasError: false &#125;, password2: &#123; hasError: true, errorMessage: '两次密码不一致' &#125;&#125;;**/ 嵌套对象对于复杂的嵌套的 Object , 可以使用 ObjectType().shape 方法进行定义，比如： 123456789const model = SchemaModel(&#123; id: NumberType().isRequired('该字段不能为空'), name: StringType().isRequired('用户名不能为空'), info: ObjectType().shape(&#123; email: StringType().isEmail('应该是一个 email'), age: numberType().min(18, '年龄应该大于18岁') &#125;);&#125;); 另外，更推荐把对象扁平化设计 12345678910111213141516171819import &#123; flaser &#125; from 'object-flaser';const model = SchemaModel(&#123; id: NumberType().isRequired('该字段不能为空'), name: StringType().isRequired('用户名不能为空'), 'info.email': StringType().isEmail('应该是一个 email'), 'info.age': numberType().min(18, '年龄应该大于18岁')&#125;);const user = flaser(&#123; id: 1, name: 'schema-type', info: &#123; email: 'schema-type@gmail.com', age: 17 &#125;&#125;);model.check(data); 组合SchemaModel 提供了一个静态方法 combine, 可以对多个 SchemaModel 合并返回一个新的 SchemaModel。 12345678910111213141516171819202122const model1 = SchemaModel(&#123; username: StringType().isRequired('用户名不能为空'), email: StringType().isEmail('请输入正确的邮箱')&#125;);const model2 = SchemaModel(&#123; username: StringType().minLength(7, '最少7个字符'), age: NumberType().range(18, 30, '年应该在 18 到 30 岁')&#125;);const model3 = SchemaModel(&#123; groupId: NumberType().isRequired('该字段不能为空')&#125;);const model4 = SchemaModel.combine(model1, model2, model3);model4.check(&#123; username: 'foobar', email: 'foo@bar.com', age: 40, groupId: 1&#125;); API SchemaModel StringType NumberType ArrayType DateType ObjectType BooleanType SchemaModelcheck(data: Object)123456789const model = SchemaModel(&#123; username: StringType().isRequired('该字段不能为空'), email: StringType().isEmail('请输入正确的邮箱')&#125;);model.check(&#123; username: 'root', email: 'root@email.com'&#125;); checkForField(fieldName: string, fieldValue: any, data: Object) 12345const model = SchemaModel(&#123; username: StringType().isRequired('该字段不能为空'), email: StringType().isEmail('请输入正确的邮箱')&#125;);model.checkForField('username', 'root'); StringType isRequired(errorMessage: string) StringType().isRequired(‘该字段不能为空’); isEmail(errorMessage: string) StringType().isEmail(‘请输入正确的邮箱地址’); isURL(errorMessage: string) StringType().isURL(‘请输入正确的URL地址’); isOneOf(items: Array, errorMessage: string) StringType().isOneOf([‘Javascript’, ‘CSS’], ‘只能输入 Javascript和 CSS‘); containsLetter(errorMessage: string) StringType().containsLetter(‘必须包含英文字符’); containsUppercaseLetter(errorMessage: string) StringType().containsUppercaseLetter(‘必须包含大写的英文字符’); containsLowercaseLetter(errorMessage: string) StringType().containsLowercaseLetter(‘必须包含小写的英文字符’); containsLetterOnly(errorMessage: string) StringType().containsLetterOnly(‘只能包含的英文字符’); containsNumber(errorMessage: string) StringType().containsNumber(‘必须包含数字’); pattern(regExp: RegExp, errorMessage: string) StringType().pattern(/^[1-9][0-9]{3}\s?[a-zA-Z]{2}$/, ‘请输入合法字符’); rangeLength(minLength: number, maxLength: number, errorMessage: string) StringType().rangeLength(6, 30, ‘字符个数只能在 6 - 30 之间’); minLength(minLength: number, errorMessage: string) StringType().minLength(6, ‘最小需要6个字符’); maxLength(maxLength: number, errorMessage: string) StringType().minLength(30, ‘最大只能30个字符’); addRule(onValid: Function, errorMessage: string) StringType().addRule((value, data) =&gt; { return /^[1-9][0-9]{3}\s?[a-zA-Z]{2}$/.test(value);}, ‘请输入合法字符’); NumberType isRequired(errorMessage: string) NumberType().isRequired(‘该字段必填’); isInteger(errorMessage: string) NumberType().isInteger(‘只能是整型’); isOneOf(items: Array, errorMessage: string) NumberType().isOneOf([5, 10, 15], ‘只能是5,10,15‘); pattern(regExp: RegExp, errorMessage: string) NumberType().pattern(/^[1-9][0-9]{3}$/, ‘请输入合法字符’); range(minLength: number, maxLength: number, errorMessage: string) NumberType().range(18, 40, ‘请输入 18 - 40 之间的数字’); min(min: number, errorMessage: string) NumberType().min(18, ‘最小值 18’); max(max: number, errorMessage: string) NumberType().max(40, ‘最大值 40’); addRule(onValid: Function, errorMessage: string) NumberType().addRule((value, data) =&gt; { return value % 5 === 0;}, ‘请输入有效的数字’); ArrayType isRequired(errorMessage: string) ArrayType().isRequired(‘该字段必填’); rangeLength(minLength: number, maxLength: number, errorMessage: string) ArrayType().rangeLength(1, 3, ‘至少选择1个，但不能超过3个’); minLength(minLength: number, errorMessage: string) ArrayType().minLength(1, ‘至少选择1个’); maxLength(maxLength: number, errorMessage: string) ArrayType().maxLength(3, ‘不能超过3个’); unrepeatable(errorMessage: string) ArrayType().unrepeatable(‘不能出现重复选项’); of(type: Object, errorMessage: string) ArrayType().of(StringType().isEmail(), ‘格式错误’); addRule(onValid: Function, errorMessage: string) ArrayType().addRule((value, data) =&gt; { return value.length % 2 === 0;}, ‘好事成双’); DateType isRequired(errorMessage: string) DateType().isRequired(‘日期不能为空’); range(min: Date, max: Date, errorMessage: string) DateType().range( new Date(‘08/01/2017’), new Date(‘08/30/2017’), ‘时间应该在 08/01/2017 - 08/30/2017 之间’); min(min: Date, errorMessage: string) DateType().min(new Date(‘08/01/2017’), ‘时间的最小值 08/01/2017’); max(max: Date, errorMessage: string) DateType().max(new Date(‘08/30/2017’), ‘时间的最大值 08/30/2017’); addRule(onValid: Function, errorMessage: string) DateType().addRule((value, data) =&gt; { return value.getDay() === 2;}, ‘只能选择周二’); ObjectType isRequired(errorMessage: string) ObjectType().isRequired(‘该对象不能为空’); shape(type: Object) ObjectType().shape({ email: StringType().isEmail(‘应该是一个 email’), age: numberType().min(18, ‘年龄应该大于18岁’)}); addRule(onValid: Function, errorMessage: string) ObjectType().addRule((value, data) =&gt; { if (value.id || value.email) { return true; } return false;}, ‘id 与 email 必须有一个不能为空’); BooleanType isRequired(errorMessage: string) BooleanType().isRequired(‘该字段不能为空’); addRule(onValid: Function, errorMessage: string) ObjectType().addRule((value, data) =&gt; { if (typeof value === ‘undefined’ &amp;&amp; A === 10) { return false; } return true;}, ‘当 A 等于 10 的时候，该值必须为空’);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[48个JS开发常用工具函数]]></title>
    <url>%2F2019%2F07%2F05%2F48%E4%B8%AAJS%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[48个JS开发常用工具函数isStatic：检测数据是不是除了symbol外的原始数据123456789function isStatic(value) &#123; return( typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'undefined' || value === null )&#125; isPrimitive：检测数据是不是原始数据123function isPrimitive(value) &#123; return isStatic(value) || typeof value === 'symbol'&#125; isObject：判断数据是不是引用类型的数据 (例如： arrays, functions, objects, regexes, new Number(0),以及 new String(‘’))1234function isObject(value) &#123; let type = typeof value; return value != null &amp;&amp; (type == 'object' || type == 'function');&#125; isObjectLike：检查 value 是否是 类对象。 如果一个值是类对象，那么它不应该是 null，而且 typeof 后的结果是 “object”123function isObjectLike(value) &#123; return value != null &amp;&amp; typeof value == 'object';&#125; getRawType：获取数据类型，返回结果为 Number、String、Object、Array等1234function getRawType(value) &#123; return Object.prototype.toString.call(value).slice(8, -1)&#125;//getoRawType([]) ==&gt; Array isPlainObject：判断数据是不是Object类型的数据123function isPlainObject(obj) &#123; return Object.prototype.toString.call(obj) === '[object Object]'&#125; isArray：判断数据是不是数组类型的数据12345function isArray(arr) &#123; return Object.prototype.toString.call(arr) === '[object Array]'&#125;将isArray挂载到Array上Array.isArray = Array.isArray || isArray; isRegExp：判断数据是不是正则对象123function isRegExp(value) &#123; return Object.prototype.toString.call(value) === '[object RegExp]'&#125; isDate：判断数据是不是时间对象123function isDate(value) &#123; return Object.prototype.toString.call(value) === '[object Date]'&#125; isNative：判断 value 是不是浏览器内置函数内置函数toString后的主体代码块为 [native code] ，而非内置函数则为相关代码，所以非内置函数可以进行拷贝(toString后掐头去尾再由Function转)123function isNative(value) &#123; return typeof value === 'function' &amp;&amp; /native code/.test(value.toString())&#125; isFunction：检查 value 是不是函数123function isFunction(value) &#123; return Object.prototype.toString.call(value) === '[object Function]'&#125; isLength：检查 value 是否为有效的类数组长度123function isLength(value) &#123; return typeof value == 'number' &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= Number.MAX_SAFE_INTEGER;&#125; isArrayLike：检查 value 是否是类数组如果一个值被认为是类数组，那么它不是一个函数，并且value.length是个整数，大于等于 0，小于或等于 Number.MAX_SAFE_INTEGER。这里字符串也将被当作类数组。123function isArrayLike(value) &#123; return value != null &amp;&amp; isLength(value.length) &amp;&amp; !isFunction(value);&#125; isEmpty：检查 value 是否为空如果是null，直接返回true；如果是类数组，判断数据长度；如果是Object对象，判断是否具有属性；如果是其他数据，直接返回false(也可改为返回true)123456789101112131415function isEmpty(value) &#123; if (value == null) &#123; return true; &#125; if (isArrayLike(value)) &#123; return !value.length; &#125;else if(isPlainObject(value))&#123; for (let key in value) &#123; if (hasOwnProperty.call(value, key)) &#123; return false; &#125; &#125; &#125; return false;&#125; cached：记忆函数：缓存函数的运算结果1234567function cached(fn) &#123; let cache = Object.create(null); return function cachedFn(str) &#123; let hit = cache[str]; return hit || (cache[str] = fn(str)) &#125;&#125; camelize：横线转驼峰命名123456789let camelizeRE = /-(\w)/g;function camelize(str) &#123; return str.replace(camelizeRE, function(_, c) &#123; return c ? c.toUpperCase() : ''; &#125;)&#125;//ab-cd-ef ==&gt; abCdEf//使用记忆函数let _camelize = cached(camelize) hyphenate：驼峰命名转横线命名：拆分字符串，使用 - 相连，并且转换为小写1234567let hyphenateRE = /\B([A-Z])/g;function hyphenate(str)&#123; return str.replace(hyphenateRE, '-$1').toLowerCase()&#125;//abCd ==&gt; ab-cd//使用记忆函数let _hyphenate = cached(hyphenate); capitalize：字符串首位大写123456function capitalize(str)&#123; return str.charAt(0).toUpperCase() + str.slice(1)&#125;// abc ==&gt; Abc//使用记忆函数let _capitalize = cached(capitalize) extend：将属性混合到目标对象中123456function extend(to, _from) &#123; for(let key in _from) &#123; to[key] = _from[key]; &#125; return to&#125; Object.assign：对象属性复制，浅拷贝1234567891011121314151617Object.assign = Object.assign || function()&#123; if(arguments.length == 0) throw new TypeError('Cannot convert undefined or null to object'); let target = arguments[0], args = Array.prototype.slice.call(arguments, 1), key args.forEach(function(item)&#123; for(key in item)&#123; item.hasOwnProperty(key) &amp;&amp; ( target[key] = item[key] ) &#125; &#125;) return target&#125;使用Object.assign可以浅克隆一个对象：let clone = Object.assign(&#123;&#125;, target)简单的深克隆可以使用JSON.parse()和JSON.stringify()，这两个api是解析json数据的，所以只能解析除symbol外的原始类型及数组和对象let clone = JSON.parse( JSON.stringify(target) ) clone：克隆数据，可深度克隆这里列出了原始类型，时间、正则、错误、数组、对象的克隆规则，其他的可自行补充123456789101112131415161718192021222324function clone(value, deep)&#123; if(isPrimitive(value))&#123; return value &#125; if (isArrayLike(value)) &#123; //是类数组 value = Array.prototype.slice.call(value) return value.map(item =&gt; deep ? clone(item, deep) : item) &#125;else if(isPlainObject(value))&#123; //是对象 let target = &#123;&#125;, key; for (key in value) &#123; value.hasOwnProperty(key) &amp;&amp; ( target[key] = deep ? clone(value[key], deep) : value[key] ) &#125; &#125; let type = getRawType(value) switch(type)&#123; case 'Date': case 'RegExp': case 'Error': value = new window[type](value); break; &#125; return value&#125; 识别各种浏览器及平台12345678910111213//运行环境是浏览器let inBrowser = typeof window !== 'undefined';//运行环境是微信let inWeex = typeof WXEnvironment !== 'undefined' &amp;&amp; !!WXEnvironment.platform;let weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase();//浏览器 UA 判断let UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase();let isIE = UA &amp;&amp; /msie|trident/.test(UA);let isIE9 = UA &amp;&amp; UA.indexOf('msie 9.0') &gt; 0;let isEdge = UA &amp;&amp; UA.indexOf('edge/') &gt; 0;let isAndroid = (UA &amp;&amp; UA.indexOf('android') &gt; 0) || (weexPlatform === 'android');let isIOS = (UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');let isChrome = UA &amp;&amp; /chrome\/\d+/.test(UA) &amp;&amp; !isEdge; getExplorerInfo：获取浏览器信息12345678910111213141516171819202122232425262728function getExplorerInfo() &#123; let t = navigator.userAgent.toLowerCase(); return 0 &lt;= t.indexOf("msie") ? &#123; //ie &lt; 11 type: "IE", version: Number(t.match(/msie ([\d]+)/)[1]) &#125; : !!t.match(/trident\/.+?rv:(([\d.]+))/) ? &#123; // ie 11 type: "IE", version: 11 &#125; : 0 &lt;= t.indexOf("edge") ? &#123; type: "Edge", version: Number(t.match(/edge\/([\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf("firefox") ? &#123; type: "Firefox", version: Number(t.match(/firefox\/([\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf("chrome") ? &#123; type: "Chrome", version: Number(t.match(/chrome\/([\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf("opera") ? &#123; type: "Opera", version: Number(t.match(/opera.([\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf("Safari") ? &#123; type: "Safari", version: Number(t.match(/version\/([\d]+)/)[1]) &#125; : &#123; type: t, version: -1 &#125;&#125; isPCBroswer：检测是否为PC端浏览器模式123456789101112function isPCBroswer() &#123; let e = navigator.userAgent.toLowerCase() , t = "ipad" == e.match(/ipad/i) , i = "iphone" == e.match(/iphone/i) , r = "midp" == e.match(/midp/i) , n = "rv:1.2.3.4" == e.match(/rv:1.2.3.4/i) , a = "ucweb" == e.match(/ucweb/i) , o = "android" == e.match(/android/i) , s = "windows ce" == e.match(/windows ce/i) , l = "windows mobile" == e.match(/windows mobile/i); return !(t || i || r || n || a || o || s || l)&#125; unique：数组去重，返回一个新数组12345678910111213141516171819202122232425function unique(arr)&#123; if(!isArrayLink(arr))&#123; //不是类数组对象 return arr &#125; let result = [] let objarr = [] let obj = Object.create(null) arr.forEach(item =&gt; &#123; if(isStatic(item))&#123;//是除了symbol外的原始数据 let key = item + '_' + getRawType(item); if(!obj[key])&#123; obj[key] = true result.push(item) &#125; &#125;else&#123;//引用类型及symbol if(!objarr.includes(item))&#123; objarr.push(item) result.push(item) &#125; &#125; &#125;) return resulte&#125; Set简单实现12345678910111213141516171819202122232425262728293031323334353637383940window.Set = window.Set || (function () &#123; function Set(arr) &#123; this.items = arr ? unique(arr) : []; this.size = this.items.length; // Array的大小 &#125; Set.prototype = &#123; add: function (value) &#123; // 添加元素,若元素已存在,则跳过，返回 Set 结构本身。 if (!this.has(value)) &#123; this.items.push(value); this.size++; &#125; return this; &#125;, clear: function () &#123; //清除所有成员，没有返回值。 this.items = [] this.size = 0 &#125;, delete: function (value) &#123; //删除某个值，返回一个布尔值，表示删除是否成功。 return this.items.some((v, i) =&gt; &#123; if(v === value)&#123; this.items.splice(i,1) return true &#125; return false &#125;) &#125;, has: function (value) &#123; //返回一个布尔值，表示该值是否为Set的成员。 return this.items.some(v =&gt; v === value) &#125;, values: function () &#123; return this.items &#125;, &#125; return Set;&#125;()); repeat：生成一个重复的字符串，有n个str组成，可修改为填充为数组等1234567891011121314function repeat(str, n) &#123; let res = ''; while(n) &#123; if(n % 2 === 1) &#123; res += str; &#125; if(n &gt; 1) &#123; str += str; &#125; n &gt;&gt;= 1; &#125; return res&#125;;//repeat('123',3) ==&gt; 123123123 dateFormater：格式化时间123456789101112131415161718function dateFormater(formater, t)&#123; let date = t ? new Date(t) : new Date(), Y = date.getFullYear() + '', M = date.getMonth() + 1, D = date.getDate(), H = date.getHours(), m = date.getMinutes(), s = date.getSeconds(); return formater.replace(/YYYY|yyyy/g,Y) .replace(/YY|yy/g,Y.substr(2,2)) .replace(/MM/g,(M&lt;10?'0':'') + M) .replace(/DD/g,(D&lt;10?'0':'') + D) .replace(/HH|hh/g,(H&lt;10?'0':'') + H) .replace(/mm/g,(m&lt;10?'0':'') + m) .replace(/ss/g,(s&lt;10?'0':'') + s)&#125;// dateFormater('YYYY-MM-DD HH:mm', t) ==&gt; 2019-06-26 18:30// dateFormater('YYYYMMDDHHmm', t) ==&gt; 201906261830 dateStrForma：将指定字符串由一种时间格式转化为另一种from的格式应对应str的位置1234567891011121314151617181920212223242526function dateStrForma(str, from, to)&#123; //'20190626' 'YYYYMMDD' 'YYYY年MM月DD日' str += '' let Y = '' if(~(Y = from.indexOf('YYYY')))&#123; Y = str.substr(Y, 4) to = to.replace(/YYYY|yyyy/g,Y) &#125;else if(~(Y = from.indexOf('YY')))&#123; Y = str.substr(Y, 2) to = to.replace(/YY|yy/g,Y) &#125; let k,i ['M','D','H','h','m','s'].forEach(s =&gt;&#123; i = from.indexOf(s+s) k = ~i ? str.substr(i, 2) : '' to = to.replace(s+s, k) &#125;) return to&#125;// dateStrForma('20190626', 'YYYYMMDD', 'YYYY年MM月DD日') ==&gt; 2019年06月26日// dateStrForma('121220190626', '----YYYYMMDD', 'YYYY年MM月DD日') ==&gt; 2019年06月26日// dateStrForma('2019年06月26日', 'YYYY年MM月DD日', 'YYYYMMDD') ==&gt; 20190626// 一般的也可以使用正则来实现//'2019年06月26日'.replace(/(\d&#123;4&#125;)年(\d&#123;2&#125;)月(\d&#123;2&#125;)日/, '$1-$2-$3') ==&gt; 2019-06-26 getPropByPath：根据字符串路径获取对象属性 : ‘obj[0].count’12345678910111213141516171819202122232425function getPropByPath(obj, path, strict) &#123; let tempObj = obj; path = path.replace(/\[(\w+)\]/g, '.$1'); //将[0]转化为.0 path = path.replace(/^\./, ''); //去除开头的. let keyArr = path.split('.'); //根据.切割 let i = 0; for (let len = keyArr.length; i &lt; len - 1; ++i) &#123; if (!tempObj &amp;&amp; !strict) break; let key = keyArr[i]; if (key in tempObj) &#123; tempObj = tempObj[key]; &#125; else &#123; if (strict) &#123;//开启严格模式，没找到对应key值，抛出错误 throw new Error('please transfer a valid prop path to form item!'); &#125; break; &#125; &#125; return &#123; o: tempObj, //原始数据 k: keyArr[i], //key值 v: tempObj ? tempObj[keyArr[i]] : null // key值对应的值 &#125;;&#125;; GetUrlParam：获取Url参数，返回一个对象1234567891011121314function GetUrlParam()&#123; let url = document.location.toString(); let arrObj = url.split("?"); let params = Object.create(null) if (arrObj.length &gt; 1)&#123; arrObj = arrObj[1].split("&amp;"); arrObj.forEach(item=&gt;&#123; item = item.split("="); params[item[0]] = item[1] &#125;) &#125; return params;&#125;// ?a=1&amp;b=2&amp;c=3 ==&gt; &#123;a: "1", b: "2", c: "3"&#125; downloadFile：base64数据导出文件，文件下载1234567891011121314151617181920212223function downloadFile(filename, data)&#123; let DownloadLink = document.createElement('a'); if ( DownloadLink )&#123; document.body.appendChild(DownloadLink); DownloadLink.style = 'display: none'; DownloadLink.download = filename; DownloadLink.href = data; if ( document.createEvent )&#123; let DownloadEvt = document.createEvent('MouseEvents'); DownloadEvt.initEvent('click', true, false); DownloadLink.dispatchEvent(DownloadEvt); &#125; else if ( document.createEventObject ) DownloadLink.fireEvent('onclick'); else if (typeof DownloadLink.onclick == 'function' ) DownloadLink.onclick(); document.body.removeChild(DownloadLink); &#125;&#125; toFullScreen：全屏123456789101112function toFullScreen()&#123; let elem = document.body; elem.webkitRequestFullScreen ? elem.webkitRequestFullScreen() : elem.mozRequestFullScreen ? elem.mozRequestFullScreen() : elem.msRequestFullscreen ? elem.msRequestFullscreen() : elem.requestFullScreen ? elem.requestFullScreen() : alert("浏览器不支持全屏");&#125; exitFullscreen：退出全屏1234567891011121314function exitFullscreen()&#123; let elem = parent.document; elem.webkitCancelFullScreen ? elem.webkitCancelFullScreen() : elem.mozCancelFullScreen ? elem.mozCancelFullScreen() : elem.cancelFullScreen ? elem.cancelFullScreen() : elem.msExitFullscreen ? elem.msExitFullscreen() : elem.exitFullscreen ? elem.exitFullscreen() : alert("切换失败,可尝试Esc退出");&#125; requestAnimationFrame：window动画12345678910111213141516171819window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) &#123; //为了使setTimteout的尽可能的接近每秒60帧的效果 window.setTimeout(callback, 1000 / 60); &#125;; window.cancelAnimationFrame = window.cancelAnimationFrame || Window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame || function (id) &#123; //为了使setTimteout的尽可能的接近每秒60帧的效果 window.clearTimeout(id); &#125; _isNaN：检查数据是否是非数字值原生的isNaN会把参数转换成数字(valueof)，而null、true、false以及长度小于等于1的数组(元素为非NaN数据)会被转换成数字，这不是我想要的。Symbol类型的数据不具有valueof接口，所以isNaN会抛出错误，这里放在后面，可避免错误123function _isNaN(v)&#123; return !(typeof v === 'string' || typeof v === 'number') || isNaN(v)&#125; max：求取数组中非NaN数据中的最大值12345function max(arr)&#123; arr = arr.filter(item =&gt; !_isNaN(item)) return arr.length ? Math.max.apply(null, arr) : undefined&#125;//max([1, 2, '11', null, 'fdf', []]) ==&gt; 11 min：求取数组中非NaN数据中的最小值12345function min(arr)&#123; arr = arr.filter(item =&gt; !_isNaN(item)) return arr.length ? Math.min.apply(null, arr) : undefined&#125;//min([1, 2, '11', null, 'fdf', []]) ==&gt; 1 random：返回一个lower - upper之间的随机数lower、upper无论正负与大小，但必须是非NaN的数据12345678function random(lower, upper)&#123; lower = +lower || 0 upper = +upper || 0 return Math.random() * (upper - lower) + lower;&#125;//random(0, 0.5) ==&gt; 0.3567039135734613//random(2, 1) ===&gt; 1.6718418553475423//random(-2, -1) ==&gt; -1.4474325452361945 Object.keys：返回一个由一个给定对象的自身可枚举属性组成的数组123456789101112Object.keys = Object.keys || function keys(object) &#123; if(object === null || object === undefined)&#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; let result = [] if(isArrayLike(object) || isPlainObject(object))&#123; for (let key in object) &#123; object.hasOwnProperty(key) &amp;&amp; ( result.push(key) ) &#125; &#125; return result&#125; Object.values：返回一个给定对象自身的所有可枚举属性值的数组123456789101112Object.values = Object.values || function values(object) &#123; if(object === null || object === undefined)&#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; let result = [] if(isArrayLike(object) || isPlainObject(object))&#123; for (let key in object) &#123; object.hasOwnProperty(key) &amp;&amp; ( result.push(object[key]) ) &#125; &#125; return result&#125; arr.fill：使用 value 值来填充 array，从start位置开始, 到end位置结束（但不包含end位置），返回原数组123456789101112131415161718192021222324Array.prototype.fill = Array.prototype.fill || function fill(value, start, end) &#123; let ctx = this let length = ctx.length; start = parseInt(start) if(isNaN(start))&#123; start = 0 &#125;else if (start &lt; 0) &#123; start = -start &gt; length ? 0 : (length + start); &#125; end = parseInt(end) if(isNaN(end) || end &gt; length)&#123; end = length &#125;else if (end &lt; 0) &#123; end += length; &#125; while (start &lt; end) &#123; ctx[start++] = value; &#125; return ctx;&#125;//Array(3).fill(2) ===&gt; [2, 2, 2] arr.includes：用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false，可指定开始查询的位置123456789101112131415Array.prototype.includes = Array.prototype.includes || function includes(value, start)&#123; let ctx = this let length = ctx.length; start = parseInt(start) if(isNaN(start))&#123; start = 0 &#125;else if (start &lt; 0) &#123; start = -start &gt; length ? 0 : (length + start); &#125; let index = ctx.indexOf(value) return index &gt;= start;&#125; arr.find：返回数组中通过测试（函数fn内判断）的第一个元素的值12345678910Array.prototype.find = Array.prototype.find || function find(fn, ctx)&#123; ctx = ctx || this let result; ctx.some((value, index, arr), thisValue) =&gt; &#123; return fn(value, index, arr) ? (result = value, true) : false &#125;) return result&#125; arr.findIndex ：返回数组中通过测试（函数fn内判断）的第一个元素的下标12345678910Array.prototype.findIndex = Array.prototype.findIndex || function findIndex(fn, ctx)&#123; ctx = ctx || this let result; ctx.some((value, index, arr), thisValue) =&gt; &#123; return fn(value, index, arr) ? (result = index, true) : false &#125;) return result&#125; performance.timing：利用performance.timing进行性能分析12345678910111213141516window.onload = function()&#123; setTimeout(function()&#123; let t = performance.timing console.log('DNS查询耗时 ：' + (t.domainLookupEnd - t.domainLookupStart).toFixed(0)) console.log('TCP链接耗时 ：' + (t.connectEnd - t.connectStart).toFixed(0)) console.log('request请求耗时 ：' + (t.responseEnd - t.responseStart).toFixed(0)) console.log('解析dom树耗时 ：' + (t.domComplete - t.domInteractive).toFixed(0)) console.log('白屏时间 ：' + (t.responseStart - t.navigationStart).toFixed(0)) console.log('domready时间 ：' + (t.domContentLoadedEventEnd - t.navigationStart).toFixed(0)) console.log('onload时间 ：' + (t.loadEventEnd - t.navigationStart).toFixed(0)) if(t = performance.memory)&#123; console.log('js内存使用占比 ：' + (t.usedJSHeapSize / t.totalJSHeapSize * 100).toFixed(2) + '%') &#125; &#125;)&#125; 禁止某些键盘事件1234567891011document.addEventListener('keydown', function(event)&#123; return !( 112 == event.keyCode || //F1 123 == event.keyCode || //F12 event.ctrlKey &amp;&amp; 82 == event.keyCode || //ctrl + R event.ctrlKey &amp;&amp; 78 == event.keyCode || //ctrl + N event.shiftKey &amp;&amp; 121 == event.keyCode || //shift + F10 event.altKey &amp;&amp; 115 == event.keyCode || //alt + F4 "A" == event.srcElement.tagName &amp;&amp; event.shiftKey //shift + 点击a标签 ) || (event.returnValue = false)&#125;); 禁止右键、选择、复制12345['contextmenu', 'selectstart', 'copy'].forEach(function(ev)&#123; document.addEventListener(ev, function(event)&#123; return event.returnValue = false &#125;)&#125;);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中级前端工程师必须要掌握的28个JavaScript技巧]]></title>
    <url>%2F2019%2F06%2F04%2F%E4%B8%AD%E7%BA%A7%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E9%A1%BB%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%8428%E4%B8%AAJavaScript%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1.判断对象的数据类型1234567const isType = type =&gt; target =&gt; `[object $&#123;type&#125;]` === Object.prototype.toString.call(target)const isArray = isType('Array')console.log(isArray([]))&gt; true 使用 Object.prototype.toString 配合闭包，通过传入不同的判断类型来返回不同的判断函数，一行代码，简洁优雅灵活（注意传入 type 参数时首字母大写） 不推荐将这个函数用来检测可能会产生包装类型的基本数据类型上,因为 call 会将第一个参数进行装箱操作]]></content>
      <categories>
        <category>javascript技巧</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter资源收集]]></title>
    <url>%2F2019%2F06%2F03%2Fflutter%E8%B5%84%E6%BA%90%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[FlutterFlutter资源收集，持续更新，欢迎大家提issue更新纠错 基础+资料 Flutter Flutter中文网 Flutter中文网2 Flutter开源库 Flutter实战 awesome-flutter: 一个flutter的项目、文档、教程的资源整合和收藏 阿里：flutter-go：flutter 开发者帮助 APP FlutterScreens: 组件集合 图表库——google charts FlutterBoost: 新一代Flutter-Native混合解决方案 Flutter插件 Flutter的日期选择器控件 Dart Dart官方主页 Dart Packages Dart语言的在线编辑器 Dart语言的在线编辑器源码 社区 掘进Flutter社区 知乎Flutter社区 Flutter 开发组件库中文社区 闲鱼技术Flutter segmentfault: 思否技术问答社区 Demo资源 仿网易云音乐 豆瓣客户端：全网最100%还原豆瓣客户端 书阁 Flutter Example Apps (Source Code + YouTube Link) 基于Google Flutter的WanAndroid客户端 Flutter 仿滴滴出行(部分开源) 基于Google Flutter的开源中国客户端 GSYGithubApp：跨平台的开源Github客户端App 时间轴Demo Flutter UIKit 高仿书旗小说 Flutter版 flutter实现超过100个精美的ui页面 Flutter的电商实战项目 InKino: 完整的电影应用程序 Beer-Me-Up Music Player: Pawan Kumar 开发的全功能音乐播放器 WhatTodo DroidKaigi2018-flutter: 东京 DroidKaigi 2018 的非官方会议应用 开发知乎App的Flutter版 仿luckin coffee的FlutterApp 天气查询App 仿掘金 Flutter仿BOSS直聘 仿开眼视频 Flutter高仿好奇心日报 flutter开发俄罗斯方块 Flutter库资源 Flutter：loading动画库 其它 flutter应用收集 MADE BY THE FLUTTER社区 日更的FlutterDemo合集 Flutter-learning: 个人开源项目，2600Star]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter常用组件学习]]></title>
    <url>%2F2019%2F05%2F25%2Fflutter%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[flutter常用组件学习text文本组件1234567891011121314child: Text( 'Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。它也是构建未来的Google Fuchsi.', textAlign: TextAlign.start, maxLines: 2, // overflow: TextOverflow.clip, // overflow: TextOverflow.fade, overflow: TextOverflow.ellipsis, style: TextStyle( fontSize: 16.0, color: Color.fromARGB(255, 125, 0, 1), decoration: TextDecoration.underline, decorationStyle: TextDecorationStyle.solid ),), Container组件 此组件有点类型html中的div 123456789101112131415161718192021 child: Container( child: new Text( 'hello wutianci', style: TextStyle( fontSize: 40.0, color: Color.fromRGBO(255, 255, 255, 1), ), ), alignment: Alignment.topLeft, width: 500.0, height: 400.0, color: Colors.lightBlue, // padding: const EdgeInsets.all(10.0), padding: const EdgeInsets.fromLTRB(20.0, 10.0, 0, 0), margin: const EdgeInsets.all(10.0), decoration: new BoxDecoration( gradient: const LinearGradient( colors: [Colors.lightBlue,Colors.greenAccent,Colors.purple] ) ),), Image组件1234567891011121314151617181920child: Container( child: new Image.network( 'https://avatars2.githubusercontent.com/u/9635737', // repeat: ImageRepeat.noRepeat, repeat: ImageRepeat.repeat, /* 混合 // color: Colors.greenAccent, // colorBlendMode: BlendMode.darken, // colorBlendMode: BlendMode.colorDodge, // colorBlendMode: BlendMode.difference, */ // fit: BoxFit.contain, // fit: BoxFit.fill, // fit: BoxFit.fitWidth fit: BoxFit.cover ), width: 300.0, height: 200.0, color: Colors.lightBlue), ListView组件1234567891011121314151617181920body: new ListView( // children: &lt;Widget&gt;[ // new ListTile( // leading: new Icon(Icons.perm_camera_mic), // title: new Text('perm_camera_mic'), // ), new ListTile( // leading: new Icon(Icons.add_call), // title: new Text('add_call'), // ), new ListTile( // leading: new Icon(Icons.access_time), // title: new Text('access_time'), // ) // ], children: &lt;Widget&gt;[ new Image.network('https://ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D300/sign=77d1cd475d43fbf2da2ca023807fca1e/9825bc315c6034a8ef5250cec5134954082376c9.jpg'), new Image.network('https://ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D300/sign=77d1cd475d43fbf2da2ca023807fca1e/9825bc315c6034a8ef5250cec5134954082376c9.jpg'), new Image.network('https://ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D300/sign=77d1cd475d43fbf2da2ca023807fca1e/9825bc315c6034a8ef5250cec5134954082376c9.jpg'), new Image.network('https://ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D300/sign=77d1cd475d43fbf2da2ca023807fca1e/9825bc315c6034a8ef5250cec5134954082376c9.jpg'), ], ), 完整代码123456789101112131415161718192021222324252627282930313233343536import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return MaterialApp( title: 'text to Flutter', home: Scaffold( appBar: AppBar( title: Text('text a to flutter'), ), body: Center( child: Container( child: new Image.network( 'https://avatars2.githubusercontent.com/u/9635737', // repeat: ImageRepeat.noRepeat, repeat: ImageRepeat.repeat, // color: Colors.greenAccent, // colorBlendMode: BlendMode.darken, // colorBlendMode: BlendMode.colorDodge, // colorBlendMode: BlendMode.difference, // fit: BoxFit.contain, // fit: BoxFit.fill, // fit: BoxFit.fitWidth fit: BoxFit.cover ), width: 300.0, height: 200.0, color: Colors.lightBlue ), ), ) ); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件间通信六种方式]]></title>
    <url>%2F2019%2F05%2F19%2Fvue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E5%85%AD%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组件是 vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系： 如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。 针对不同的使用场景，如何选择行之有效的通信方式？这是我们所要探讨的主题。总结了vue组件间通信的几种方式，如props、$emit/$on、vuex、$parent / $children、$attrs/$listeners和provide/inject， props/$emit父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。 1.父组件向子组件传值接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件Users.vue中如何获取父组件App.vue中的数据 users:[“Henry”,”Bucky”,”Emily”] 12345678910111213141516171819//App.vue父组件&lt;template&gt; &lt;div id="app"&gt; &lt;users v-bind:users="users"&gt;&lt;/users&gt;//前者自定义名称便于子组件调用，后者要传递数据名 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Users from "./components/Users"export default &#123; name: 'App', data()&#123; return&#123; users:["Henry","Bucky","Emily"] &#125; &#125;, components:&#123; "users":Users &#125;&#125; 12345678910111213141516171819复制代码//users子组件&lt;template&gt; &lt;div class="hello"&gt; &lt;ul&gt; &lt;li v-for="user in users"&gt;&#123;&#123;user&#125;&#125;&lt;/li&gt;//遍历传递过来的值，然后呈现到页面 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', props:&#123; users:&#123; //这个就是父组件中子标签自定义名字 type:Array, required:true &#125; &#125;&#125;&lt;/script&gt; 复制代码总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed 2.子组件向父组件传值（通过事件形式）接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。123456789101112131415161718192021// 子组件&lt;template&gt; &lt;header&gt; &lt;h1 @click="changeTitle"&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;//绑定一个点击事件 &lt;/header&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app-header', data() &#123; return &#123; title:"Vue.js Demo" &#125; &#125;, methods:&#123; changeTitle() &#123; this.$emit("titleChanged","子向父组件传值");//自定义事件 传递值“子向父组件传值” &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021222324252627复制代码// 父组件&lt;template&gt; &lt;div id="app"&gt; &lt;app-header v-on:titleChanged="updateTitle" &gt;&lt;/app-header&gt;//与子组件titleChanged自定义事件保持一致 // updateTitle($event)接受传递过来的文字 &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Header from "./components/Header"export default &#123; name: 'App', data()&#123; return&#123; title:"传递的是一个值" &#125; &#125;, methods:&#123; updateTitle(e)&#123; //声明这个函数 this.title = e; &#125; &#125;, components:&#123; "app-header":Header, &#125;&#125;&lt;/script&gt; 复制代码总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。 $emit/$on这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。 1.具体实现方式：123var Event=new Vue();Event.$emit(事件名,数据);Event.$on(事件名,data =&gt; &#123;&#125;); 2.举个例子假设兄弟组件有三个，分别是A、B、C组件，C组件如何获取A或者B组件的数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;div id="itany"&gt; &lt;my-a&gt;&lt;/my-a&gt; &lt;my-b&gt;&lt;/my-b&gt; &lt;my-c&gt;&lt;/my-c&gt;&lt;/div&gt;&lt;template id="a"&gt; &lt;div&gt; &lt;h3&gt;A组件：&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;button @click="send"&gt;将数据发送给C组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="b"&gt; &lt;div&gt; &lt;h3&gt;B组件：&#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;button @click="send"&gt;将数组发送给C组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="c"&gt; &lt;div&gt; &lt;h3&gt;C组件：&#123;&#123;name&#125;&#125;，&#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var Event = new Vue();//定义一个空的Vue实例var A = &#123; template: '#a', data() &#123; return &#123; name: 'tom' &#125; &#125;, methods: &#123; send() &#123; Event.$emit('data-a', this.name); &#125; &#125;&#125;var B = &#123; template: '#b', data() &#123; return &#123; age: 20 &#125; &#125;, methods: &#123; send() &#123; Event.$emit('data-b', this.age); &#125; &#125;&#125;var C = &#123; template: '#c', data() &#123; return &#123; name: '', age: "" &#125; &#125;, mounted() &#123;//在模板编译完成后执行 Event.$on('data-a',name =&gt; &#123; this.name = name;//箭头函数内部不会产生新的this，这边如果不用=&gt;,this指代Event &#125;) Event.$on('data-b',age =&gt; &#123; this.age = age; &#125;) &#125;&#125;var vm = new Vue(&#123; el: '#itany', components: &#123; 'my-a': A, 'my-b': B, 'my-c': C &#125;&#125;); &lt;/script&gt; $on 监听了自定义事件 data-a和data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。 vuex 1.简要介绍Vuex原理Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。 2.简要介绍各模块在流程中的功能： Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch：操作行为触发方法，是唯一能执行action的方法。 actions：操作行为处理模块,由组件中的$store.dispatch(‘action 名称’, data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。mutations：状态改变操作方法，由actions中的commit(‘mutation 名称’)来触发。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。 Vuex与localStoragevuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state。1234567891011121314151617181920let defaultCity = "上海"try &#123; // 用户关闭了本地存储功能，此时在外层加个try...catch if (!defaultCity)&#123; defaultCity = JSON.parse(window.localStorage.getItem('defaultCity')) &#125;&#125;catch(e)&#123;&#125;export default new Vuex.Store(&#123; state: &#123; city: defaultCity &#125;, mutations: &#123; changeCity(state, city) &#123; state.city = city try &#123; window.localStorage.setItem('defaultCity', JSON.stringify(state.city)); // 数据改变的时候把数据拷贝一份保存到localStorage里面 &#125; catch (e) &#123;&#125; &#125; &#125;&#125;) 这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换：12JSON.stringify(state.subscribeList); // array -&gt; stringJSON.parse(window.localStorage.getItem("subscribeList")); // string -&gt; array $attrs/$listeners多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法—-$attrs/$listeners $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 interitAttrs 选项一起使用。 $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件 接下来我们看个跨级通信的例子：123456789101112131415161718192021222324252627// index.vue&lt;template&gt; &lt;div&gt; &lt;h2&gt;浪里行舟&lt;/h2&gt; &lt;child-com1 :foo="foo" :boo="boo" :coo="coo" :doo="doo" title="前端工匠" &gt;&lt;/child-com1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom1 = () =&gt; import("./childCom1.vue");export default &#123; components: &#123; childCom1 &#125;, data() &#123; return &#123; foo: "Javascript", boo: "Html", coo: "CSS", doo: "Vue" &#125;; &#125;&#125;;&lt;/script&gt; 123456789101112131415161718192021222324// childCom1.vue&lt;template class="border"&gt; &lt;div&gt; &lt;p&gt;foo: &#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt; &lt;child-com2 v-bind="$attrs"&gt;&lt;/child-com2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom2 = () =&gt; import("./childCom2.vue");export default &#123; components: &#123; childCom2 &#125;, inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性 props: &#123; foo: String // foo作为props属性绑定 &#125;, created() &#123; console.log(this.$attrs); // &#123; "boo": "Html", "coo": "CSS", "doo": "Vue", "title": "前端工匠" &#125; &#125;&#125;;&lt;/script&gt; 123456789101112131415161718192021222324// childCom2.vue&lt;template&gt; &lt;div class="border"&gt; &lt;p&gt;boo: &#123;&#123; boo &#125;&#125;&lt;/p&gt; &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt; &lt;child-com3 v-bind="$attrs"&gt;&lt;/child-com3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom3 = () =&gt; import("./childCom3.vue");export default &#123; components: &#123; childCom3 &#125;, inheritAttrs: false, props: &#123; boo: String &#125;, created() &#123; console.log(this.$attrs); // &#123; "boo": "Html", "coo": "CSS", "doo": "Vue", "title": "前端工匠" &#125; &#125;&#125;;&lt;/script&gt; 1234567891011121314// childCom3.vue&lt;template&gt; &lt;div class="border"&gt; &lt;p&gt;childCom3: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; coo: String, title: String &#125;&#125;;&lt;/script&gt; 如上图所示$attrs表示没有继承数据的对象，格式为{属性名：属性值}。Vue2.4提供了$attrs , $listeners 来传递数据与事件，跨级组件之间的通讯变得更简单。 简单来说：$attrs与$listeners 是两个对象，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。 provide/inject1.简介Vue2.2.0新增API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 2.举个例子假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件123456// A.vueexport default &#123; provide: &#123; name: '浪里行舟' &#125;&#125; 1234567// B.vueexport default &#123; inject: ['name'], mounted () &#123; console.log(this.name); // 浪里行舟 &#125;&#125; 可以看到，在 A.vue 里，我们设置了一个 provide: name，值为 浪里行舟，它的作用就是将 name 这个变量提供给它的所有子组件。而在 B.vue 中，通过 inject 注入了从 A 组件中提供的 name 变量，那么在组件 B 中，就可以直接通过 this.name 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。需要注意的是：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的—-vue官方文档所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的，仍然是 浪里行舟。 3.provide与inject 怎么实现数据响应式一般来说，有两种办法： provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods使用2.6最新API Vue.observable 优化响应式 provide(推荐) 我们来看个例子：孙组件D、E和F获取A组件传递过来的color值，并能实现数据响应式变化，即A组件的color变化后，组件D、E、F不会跟着变（核心代码如下：） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// A 组件 &lt;div&gt; &lt;h1&gt;A 组件&lt;/h1&gt; &lt;button @click="() =&gt; changeColor()"&gt;改变color&lt;/button&gt; &lt;ChildrenB /&gt; &lt;ChildrenC /&gt;&lt;/div&gt;...... data() &#123; return &#123; color: "blue" &#125;; &#125;, // provide() &#123; // return &#123; // theme: &#123; // color: this.color //这种方式绑定的数据并不是可响应的 // &#125; // 即A组件的color变化后，组件D、E、F不会跟着变 // &#125;; // &#125;, provide() &#123; return &#123; theme: this//方法一：提供祖先组件的实例 &#125;; &#125;, methods: &#123; changeColor(color) &#123; if (color) &#123; this.color = color; &#125; else &#123; this.color = this.color === "blue" ? "red" : "blue"; &#125; &#125; &#125; // 方法二:使用2.6最新API Vue.observable 优化响应式 provide // provide() &#123; // this.theme = Vue.observable(&#123; // color: "blue" // &#125;); // return &#123; // theme: this.theme // &#125;; // &#125;, // methods: &#123; // changeColor(color) &#123; // if (color) &#123; // this.theme.color = color; // &#125; else &#123; // this.theme.color = this.theme.color === "blue" ? "red" : "blue"; // &#125; // &#125; // &#125; 12345678910111213141516// F 组件 &lt;template functional&gt; &lt;div class="border2"&gt; &lt;h3 :style="&#123; color: injections.theme.color &#125;"&gt;F 组件&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; inject: &#123; theme: &#123; //函数式组件取值不一样 default: () =&gt; (&#123;&#125;) &#125; &#125;&#125;;&lt;/script&gt; 虽说provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！ $parent / $children与 ref ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例 需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 ref来访问组件的例子： 12345678910111213// component-a 子组件export default &#123; data () &#123; return &#123; title: 'Vue.js' &#125; &#125;, methods: &#123; sayHello () &#123; window.alert('Hello'); &#125; &#125;&#125; 12345678910111213// 父组件&lt;template&gt; &lt;component-a ref="comA"&gt;&lt;/component-a&gt;&lt;/template&gt;&lt;script&gt; export default &#123; mounted () &#123; const comA = this.$refs.comA; console.log(comA.title); // Vue.js comA.sayHello(); // 弹窗 &#125; &#125;&lt;/script&gt; 复制代码不过，这两种方法的弊端是，无法在跨级或兄弟间通信。1234// parent.vue&lt;component-a&gt;&lt;/component-a&gt;&lt;component-b&gt;&lt;/component-b&gt;&lt;component-b&gt;&lt;/component-b&gt; 我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。 总结常见使用场景可以分为三类： 父子通信：父向子传递数据是通过 props，子向父是通过 events（$emit）；通过父链 / 子链也可以通信（$parent / $children）；ref 也可以访问组件实例；provide / inject API；$attrs/$listeners 兄弟通信：Bus；Vuex 跨级通信：Bus；Vuex；provide / inject API、$attrs/$listeners]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javscript</tag>
        <tag>vue</tag>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa构建大型项目]]></title>
    <url>%2F2019%2F05%2F14%2Fkoa%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[koaKoa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。 原生http服务器学习过Nodejs的朋友肯定对下面这段代码非常熟悉： 123456const http = require('http');let server = http.createServer((req, res) =&gt; &#123; // ....回调函数，输出hello world res.end('hello world!')&#125;)server.listen(3000) 就这样简单几行代码，就搭建了一个简单的服务器，服务器以回调函数的形式处理HTTP请求。上面这段代码还有一种更加清晰的等价形式，代码如下： 123456let server = new http.Server();server.on("request", function(req, res)&#123; // ....回调函数，输出hello world res.end('hello world!')&#125;);server.listen(3000); 首先创建了一个HttpServer的实例，对该实例进行request事件监听，server在3000端口进行监听。HttpServer继承与net.Server，它使用http_parser对连接的socket对象进行解析，当解析完成http header之后，会触发request事件，body数据继续保存在流中，直到使用data事件接收数据。 req是http.IncomingMessage实例(同时实现了Readable Stream接口)，详情请参看文档 res是http.ServerResponse实例(同时实现了Writable Stream接口)，详情请参看文档 Koa写HTTP服务器Koa 应用程序是一个包含一组中间件函数的对象，它是按照类似堆栈的方式组织和执行的。 12345678const Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = 'Hello World';&#125;);app.listen(3000); Koa写http服务器的形式与我们直接通过node http模块写的方式差别很大。第一部分析可知，node的http服务器创建来自于http.createServer等方法，Koa中是如何从原生方法封装成koa形式的服务器呢？搞懂这个原理也就搞懂了Koa框架设计的理念。 koa中的ctx对象server.context 扩展ctx的原型， 相当于ctx.prototype ctx.requestctx.response ctx.method 请求方法ctx.urlctx.pathctx.queryctx.ip 访客ipctx.headers 请求头 ctx.throw 报错退出12345router.get('/login', async ctx =&gt; &#123; if (!ctx.query.user || !ctx.query.pass) &#123; ctx.throw(400, "user and password"); &#125;&#125;) ctx.assert1234router.get('/login', async ctx =&gt; &#123; ctx.assert(ctx.query.user, 400, 'username is required'); ctx.assert(ctx.query.password, 400, 'password is required');&#125;) ctx.state = 200;ctx.redirect 重定向 koa-router!!!未完待续…]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javscript高阶函数浅析]]></title>
    <url>%2F2019%2F05%2F12%2Fjavscript%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[高阶函数 高阶函数英文叫 Higher-order function，它的定义很简单，就是至少满足下列一个条件的函数： 接受一个或多个函数作为输入 输出一个函数 也就是说高阶函数是对其他函数进行操作的函数，可以将它们作为参数传递，或者是返回它们。 简单来说，高阶函数是一个接收函数作为参数传递或者将函数作为返回值输出的函数。 函数作为参数传递JavaScript 语言中内置了一些高阶函数，比如 Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce，它们接受一个函数作为参数，并应用这个函数到列表的每一个元素。我们来看看使用它们与不使用高阶函数的方案对比。 Array.prototype.mapmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果，原始数组不会改变。传递给 map 的回调函数（callback）接受三个参数，分别是 currentValue、index（可选）、array（可选），除了 callback 之外还可以接受 this 值（可选），用于执行 callback 函数时使用的this 值。 来个简单的例子方便理解，现在有一个数组 [1, 2, 3, 4]，我们想要生成一个新数组，其每个元素皆是之前数组的两倍，那么我们有下面两种使用高阶和不使用高阶函数的方式来实现。 不使用高阶函数12345678910const arr1 = [1, 2, 3, 4];const arr2 = [];for (let i = 0; i &lt; arr1.length; i++) &#123; arr2.push( arr1[i] * 2);&#125;console.log( arr2 );// [2, 4, 6, 8]console.log( arr1 );// [1, 2, 3, 4] 使用高阶函数1234567const arr1 = [1, 2, 3, 4];const arr2 = arr1.map(item =&gt; item * 2);console.log( arr2 );// [2, 4, 6, 8]console.log( arr1 );// [1, 2, 3, 4] Array.prototype.filterfilter() 方法创建一个新数组, 其包含通过提供函数实现的测试的所有元素，原始数组不会改变。接收的参数和 map 是一样的，其返回值是一个新数组、由通过测试的所有元素组成，如果没有任何数组元素通过测试，则返回空数组。 来个例子介绍下，现在有一个数组 [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]，我们想要生成一个新数组，这个数组要求没有重复的内容，即为去重。 不使用高阶函数123456789101112const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];const arr2 = [];for (let i = 0; i &lt; arr1.length; i++) &#123; if (arr1.indexOf( arr1[i] ) === i) &#123; arr2.push( arr1[i] ); &#125;&#125;console.log( arr2 );// [1, 2, 3, 5, 4]console.log( arr1 );// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4] 使用高阶函数123456789const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];const arr2 = arr1.filter( (element, index, self) =&gt; &#123; return self.indexOf( element ) === index;&#125;);console.log( arr2 );// [1, 2, 3, 5, 4]console.log( arr1 );// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4] Array.prototype.reducereduce() 方法对数组中的每个元素执行一个提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。传递给 reduce 的回调函数（callback）接受四个参数，分别是累加器 accumulator、currentValue、currentIndex（可选）、array（可选），除了 callback 之外还可以接受初始值 initialValue 值（可选）。 如果没有提供 initialValue，那么第一次调用 callback 函数时，accumulator 使用原数组中的第一个元素，currentValue 即是数组中的第二个元素。 在没有初始值的空数组上调用 reduce 将报错。 如果提供了 initialValue，那么将作为第一次调用 callback 函数时的第一个参数的值，即 accumulator，currentValue 使用原数组中的第一个元素。 来个简单的例子介绍下，现在有一个数组 [0, 1, 2, 3, 4]，需要计算数组元素的和，需求比较简单，来看下代码实现。 不使用高阶函数12345678910const arr = [0, 1, 2, 3, 4];let sum = 0;for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i];&#125;console.log( sum );// 10console.log( arr );// [0, 1, 2, 3, 4] 使用高阶函数12345678910# 无 initialValue 值const arr = [0, 1, 2, 3, 4];let sum = arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue;&#125;);console.log( sum );// 10console.log( arr );// [0, 1, 2, 3, 4] 上面是没有 initialValue 的情况，代码的执行过程如下，callback 总共调用四次。 callback accumulator currentValue currentIndex array return value first call 0 1 1 [0, 1, 2, 3, 4] 1 second call 1 2 2 [0, 1, 2, 3, 4] 3 third call 3 3 3 [0, 1, 2, 3, 4] 6 fourth call 6 4 4 [0, 1, 2, 3, 4] 10 我们再来看下有 initialValue 的情况，假设 initialValue 值为 10，我们看下代码。12345678910# 有 initialValue 值const arr = [0, 1, 2, 3, 4];let sum = arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue;&#125;, 10);console.log( sum );// 20console.log( arr );// [0, 1, 2, 3, 4] 代码的执行过程如下所示，callback 总共调用五次。 callback accumulator currentValue currentIndex array return value first call 10 0 0 [0, 1, 2, 3, 4] 10 second call 10 1 1 [0, 1, 2, 3, 4] 11 third call 11 2 2 [0, 1, 2, 3, 4] 13 fourth call 13 3 3 [0, 1, 2, 3, 4] 16 fifth call 16 4 4 [0, 1, 2, 3, 4] 20]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javscript</tag>
        <tag>高阶函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript设计模式之适配器模式]]></title>
    <url>%2F2019%2F05%2F12%2Fjavascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式 定义：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 本质：转换匹配，复用功能 适配器模式可用来在现有接口和不兼容的类之间进行适配。使用这种模式的对象又叫包装器，因为它们是在用一个新的接口包装另一个对象。许多时候创建适配器对程序员和接口的设计人员都有好处。在设计类的时候往往会遇到有些接口不能与现有API一同使用的情况。借助于适配器，你不用直接修改这些类也能使用它们。在设计大型系统和遗留框架的情况下，他的优点往往比缺点更突出。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javscript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript设计模式之单例模式]]></title>
    <url>%2F2019%2F05%2F11%2Fjavascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。例如：线程池，全局缓存，登录浮窗。首先我们需要把单例的逻辑代码单独提取，然后使用惰性单例的方式，也就是返回方法。只有在点击的时候，才会进行执行。 javascript的单例，跟类不一样。无需创建多余的构造函数这些，直接创建全局变量即可。 12345678910111213141516171819202122232425262728!(function () &#123; //管理单例的逻辑代码，如果没有数据则创建，有数据则返回 var getSingle = function(fn)&#123; //参数为创建对象的方法 var result; return function()&#123; //判断是Null或赋值 return result || (result = fn.apply(this,arguments)); &#125;; &#125;; //创建登录窗口方法 var createLoginLayer = function()&#123; var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild(div); return div; &#125;; //单例方法 var createSingleLoginLayer = getSingle(createLoginLayer); //使用惰性单例，进行创建 document.getElementById('loginBtn').onclick = function()&#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block'; &#125;;&#125;)()]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javscript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
